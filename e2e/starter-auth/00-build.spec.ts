import { test, expect } from '@playwright/test'
import * as path from 'path'
import * as fs from 'fs'

const exampleDir = path.join(process.cwd(), 'examples/starter-auth')

test.describe('Build Validation', () => {
  test('should have valid production build artifacts', async () => {
    // Note: Build is done by Playwright webServer before tests run
    // This test validates the build artifacts are present and valid

    // Verify build output exists
    const nextBuildDir = path.join(exampleDir, '.next')
    expect(fs.existsSync(nextBuildDir)).toBe(true)

    // Verify production build files exist
    const serverFile = path.join(nextBuildDir, 'standalone/server.js')
    const buildManifest = path.join(nextBuildDir, 'build-manifest.json')

    // Check that either standalone or standard build exists
    const hasStandaloneBuild = fs.existsSync(serverFile)
    const hasBuildManifest = fs.existsSync(buildManifest)

    expect(hasStandaloneBuild || hasBuildManifest).toBe(true)

    console.log('Production build artifacts validated!')
  })

  test('should have generated schema and types', async () => {
    // Note: Schema is generated by global-setup before tests run
    // This test validates the generated files exist

    // Verify generated files exist
    const prismaSchemaPath = path.join(exampleDir, 'prisma/schema.prisma')
    const typesPath = path.join(exampleDir, '.opensaas/types.ts')
    const contextPath = path.join(exampleDir, '.opensaas/context.ts')

    expect(fs.existsSync(prismaSchemaPath)).toBe(true)
    expect(fs.existsSync(typesPath)).toBe(true)
    expect(fs.existsSync(contextPath)).toBe(true)

    console.log('Schema and types validated!')
  })

  test('should have all required dependencies installed', async () => {
    const nodeModulesPath = path.join(exampleDir, 'node_modules')
    expect(fs.existsSync(nodeModulesPath)).toBe(true)

    // Check for critical dependencies
    const criticalDeps = [
      '@opensaas/stack-core',
      '@opensaas/stack-auth',
      '@opensaas/stack-ui',
      'next',
      'react',
      'better-auth',
      '@prisma/client',
    ]

    for (const dep of criticalDeps) {
      const depPath = path.join(nodeModulesPath, dep)
      expect(fs.existsSync(depPath)).toBe(true)
    }
  })

  test('should have valid environment configuration', async () => {
    const envExamplePath = path.join(exampleDir, '.env.example')

    // .env.example should exist
    expect(fs.existsSync(envExamplePath)).toBe(true)

    const envExample = fs.readFileSync(envExamplePath, 'utf-8')

    // Should have required env vars defined
    expect(envExample).toContain('DATABASE_URL')
    expect(envExample).toContain('BETTER_AUTH_SECRET')
    expect(envExample).toContain('BETTER_AUTH_URL')
  })

  test('should have valid Next.js configuration', async () => {
    const nextConfigPath = path.join(exampleDir, 'next.config.js')

    expect(fs.existsSync(nextConfigPath)).toBe(true)

    // File should contain valid Next.js config
    const configContent = fs.readFileSync(nextConfigPath, 'utf-8')
    expect(configContent).toContain('module.exports')
  })

  test('should have valid opensaas.config.ts', async () => {
    const configPath = path.join(exampleDir, 'opensaas.config.ts')

    expect(fs.existsSync(configPath)).toBe(true)

    // File should contain config export
    const configContent = fs.readFileSync(configPath, 'utf-8')
    expect(configContent).toContain('export default config')
    expect(configContent).toContain('authPlugin')
    expect(configContent).toContain('lists')
  })
})
