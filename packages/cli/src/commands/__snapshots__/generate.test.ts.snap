// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Generate Command Integration > Generator Integration > should generate all files for a basic config > context 1`] = `
"/**
 * Auto-generated context factory
 *
 * This module provides a simple API for creating OpenSaas contexts.
 * It abstracts away Prisma client management and configuration.
 *
 * DO NOT EDIT - This file is automatically generated by 'pnpm generate'
 */

import { getContext as getOpensaasContext } from '@opensaas/stack-core'
import type { Session as OpensaasSession, OpenSaasConfig } from '@opensaas/stack-core'
import { PrismaClient } from './prisma-client/client'
import type { Context } from './types'
import { prismaExtensions } from './prisma-extensions'
import configOrPromise from '../opensaas.config'

// Resolve config if it's a Promise (when plugins are present)
const configPromise = Promise.resolve(configOrPromise)
let resolvedConfig: OpenSaasConfig | null = null

// Internal Prisma singleton - managed automatically
const globalForPrisma = globalThis as unknown as { prisma: ReturnType<typeof createExtendedPrisma> | null }
let prisma: ReturnType<typeof createExtendedPrisma> | null = null

/**
 * Create Prisma client with result extensions
 */
function createExtendedPrisma(basePrisma: PrismaClient) {
  // Check if there are any extensions to apply
  if (Object.keys(prismaExtensions).length === 0) {
    return basePrisma
  }
  // Apply result extensions
  return basePrisma.$extends(prismaExtensions)
}

async function getPrisma() {
  if (!prisma) {
    if (!resolvedConfig) {
      resolvedConfig = await configPromise
    }
    const basePrisma = resolvedConfig.db.prismaClientConstructor!(PrismaClient)
    const extendedPrisma = createExtendedPrisma(basePrisma)
    prisma = globalForPrisma.prisma ?? extendedPrisma
    if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
  }
  return prisma
}

async function getConfig() {
  if (!resolvedConfig) {
    resolvedConfig = await configPromise
  }
  return resolvedConfig
}

/**
 * Storage utilities (not configured)
 */
const storage = {
  uploadFile: async () => {
    throw new Error('Storage is not configured. Add storage providers to your opensaas.config.ts')
  },
  uploadImage: async () => {
    throw new Error('Storage is not configured. Add storage providers to your opensaas.config.ts')
  },
  deleteFile: async () => {
    throw new Error('Storage is not configured. Add storage providers to your opensaas.config.ts')
  },
  deleteImage: async () => {
    throw new Error('Storage is not configured. Add storage providers to your opensaas.config.ts')
  },
}

/**
 * Get OpenSaas context with optional session
 *
 * @param session - Optional session object (structure defined by your application)
 *
 * @example
 * \`\`\`typescript
 * // Anonymous access
 * const context = await getContext()
 * const posts = await context.db.post.findMany()
 *
 * // Authenticated access
 * const context = await getContext({ userId: 'user-123' })
 * const myPosts = await context.db.post.findMany()
 *
 * // With custom session type
 * type CustomSession = { userId: string; email: string; role: string } | null
 * const context = await getContext<CustomSession>({ userId: '123', email: 'user@example.com', role: 'admin' })
 * // context.session is now typed as CustomSession
 * \`\`\`
 */
export async function getContext<TSession extends OpensaasSession = OpensaasSession>(session?: TSession): Promise<Context<TSession>> {
  const config = await getConfig()
  const prismaClient = await getPrisma()
  return getOpensaasContext(config, prismaClient, session ?? null, storage) as unknown as Context<TSession>
}

/**
 * Raw context for synchronous initialization (e.g., Better-auth setup)
 * This is only available after config is resolved, use with caution
 */
export const rawOpensaasContext = (async () => {
  const config = await getConfig()
  const prismaClient = await getPrisma()
  return getOpensaasContext(config, prismaClient, null, storage) as unknown as Context
})()

/**
 * Re-export resolved config for use in admin pages and server actions
 * This is a promise that resolves to the config
 */
export const config = getConfig()
"
`;

exports[`Generate Command Integration > Generator Integration > should generate all files for a basic config > prisma-schema 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}

model User {
  id        String   @id @default(cuid())
  name         String
  email        String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
"
`;

exports[`Generate Command Integration > Generator Integration > should generate all files for a basic config > types 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name: string
  email: string
}

export type UserUpdateInput = {
  name?: string
  email?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
  email?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Generate Command Integration > Generator Integration > should generate consistent output across multiple runs > consistent-output 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}

model User {
  id        String   @id @default(cuid())
  name         String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
"
`;

exports[`Generate Command Integration > Generator Integration > should handle different database providers > mysql-provider 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "mysql"
}
"
`;

exports[`Generate Command Integration > Generator Integration > should handle different database providers > postgresql-provider 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "postgresql"
}
"
`;

exports[`Generate Command Integration > Generator Integration > should handle different database providers > sqlite-provider 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}
"
`;

exports[`Generate Command Integration > Generator Integration > should handle empty lists config > empty-lists-schema 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}
"
`;

exports[`Generate Command Integration > Generator Integration > should handle empty lists config > empty-lists-types 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  
> & {
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Generate Command Integration > Generator Integration > should overwrite existing files > overwrite-after 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}

model Post {
  id        String   @id @default(cuid())
  title        String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
"
`;

exports[`Generate Command Integration > Generator Integration > should overwrite existing files > overwrite-before 1`] = `
"generator client {
  provider = "prisma-client"
  output   = "../.opensaas/prisma-client"
}

datasource db {
  provider = "sqlite"
}

model User {
  id        String   @id @default(cuid())
  name         String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
"
`;
