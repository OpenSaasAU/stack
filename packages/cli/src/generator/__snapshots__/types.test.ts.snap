// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Types Generator > generateTypes > should generate Context type with all operations 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate CreateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
  content?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post'
> & {
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate UpdateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
  content?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post'
> & {
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate WhereInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate type definitions for basic model 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name: string
  email: string
}

export type UserUpdateInput = {
  name?: string
  email?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
  email?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate types for multiple lists 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
}

export type PostUpdateInput = {
  title?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Virtual fields for Comment - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type CommentVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Comment - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type CommentTransformedFields = {
  // No transformed fields defined
}

export type CommentOutput = {
  id: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & CommentVirtualFields

export type Comment = CommentOutput

export type CommentCreateInput = {
  content?: string
}

export type CommentUpdateInput = {
  content?: string
}

export type CommentWhereInput = {
  id?: string
  AND?: Array<CommentWhereInput>
  OR?: Array<CommentWhereInput>
  NOT?: CommentWhereInput
  content?: { equals?: string, not?: string }
}

/**
 * Hook types for Comment list
 * Properly typed to use Prisma's generated input types
 */
export type CommentHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.CommentCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.CommentUpdateInput
        item: Comment
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.CommentCreateInput | Prisma.CommentUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Comment
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type CommentSelect = Prisma.CommentSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user' | 'post' | 'comment'
> & {
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  comment: {
    findUnique: <T extends Prisma.CommentFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.CommentFindUniqueArgs>
    ) => Promise<(Omit<Prisma.CommentGetPayload<T>, keyof CommentTransformedFields> & CommentTransformedFields & CommentVirtualFields) | null>
    findMany: <T extends Prisma.CommentFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.CommentFindManyArgs>
    ) => Promise<Array<Omit<Prisma.CommentGetPayload<T>, keyof CommentTransformedFields> & CommentTransformedFields & CommentVirtualFields>>
    create: <T extends Prisma.CommentCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.CommentCreateArgs>
    ) => Promise<Omit<Prisma.CommentGetPayload<T>, keyof CommentTransformedFields> & CommentTransformedFields & CommentVirtualFields>
    update: <T extends Prisma.CommentUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.CommentUpdateArgs>
    ) => Promise<(Omit<Prisma.CommentGetPayload<T>, keyof CommentTransformedFields> & CommentTransformedFields & CommentVirtualFields) | null>
    delete: <T extends Prisma.CommentDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.CommentDeleteArgs>
    ) => Promise<(Omit<Prisma.CommentGetPayload<T>, keyof CommentTransformedFields> & CommentTransformedFields & CommentVirtualFields) | null>
    count: (args?: Prisma.CommentCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in CreateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Include type for Post
 * No virtual fields defined, uses Prisma's Include type directly
 */
export type PostInclude = Prisma.PostInclude

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post' | 'user'
> & {
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in UpdateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Include type for Post
 * No virtual fields defined, uses Prisma's Include type directly
 */
export type PostInclude = Prisma.PostInclude

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post' | 'user'
> & {
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in types 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  posts?: PostOutput[]
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }> }
}

export type UserUpdateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }>, disconnect: Array<{ id: string }> }
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * Include type for User
 * No virtual fields defined, uses Prisma's Include type directly
 */
export type UserInclude = Prisma.UserInclude

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * Include type for Post
 * No virtual fields defined, uses Prisma's Include type directly
 */
export type PostInclude = Prisma.PostInclude

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user' | 'post'
> & {
  user: {
    findUnique: <T extends Prisma.UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserFindUniqueArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    findMany: <T extends Prisma.UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>
    ) => Promise<Array<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>>
    create: <T extends Prisma.UserCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserCreateArgs>
    ) => Promise<Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields>
    update: <T extends Prisma.UserUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserUpdateArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    delete: <T extends Prisma.UserDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.UserDeleteArgs>
    ) => Promise<(Omit<Prisma.UserGetPayload<T>, keyof UserTransformedFields> & UserTransformedFields & UserVirtualFields) | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
  post: {
    findUnique: <T extends Prisma.PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostFindUniqueArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    findMany: <T extends Prisma.PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, Prisma.PostFindManyArgs>
    ) => Promise<Array<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>>
    create: <T extends Prisma.PostCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostCreateArgs>
    ) => Promise<Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields>
    update: <T extends Prisma.PostUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostUpdateArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    delete: <T extends Prisma.PostDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.PostDeleteArgs>
    ) => Promise<(Omit<Prisma.PostGetPayload<T>, keyof PostTransformedFields> & PostTransformedFields & PostVirtualFields) | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Context type compatible with AccessContext but with CustomDB for virtual field typing
 * Extends AccessContext and overrides db property to include virtual fields in output types
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;
