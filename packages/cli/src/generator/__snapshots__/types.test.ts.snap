// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Types Generator > generateTypes > should generate Context type with all operations 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type User = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should generate CreateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type Post = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
  content?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should generate UpdateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type Post = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
  content?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should generate WhereInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type User = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should generate type definitions for basic model 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type User = {
  id: string
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name: string
  email: string
}

export type UserUpdateInput = {
  name?: string
  email?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
  email?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should generate types for multiple lists 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type User = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Post = {
  id: string
  title: string | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title?: string
}

export type PostUpdateInput = {
  title?: string
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

export type Comment = {
  id: string
  content: string | null
  createdAt: Date
  updatedAt: Date
}

export type CommentCreateInput = {
  content?: string
}

export type CommentUpdateInput = {
  content?: string
}

export type CommentWhereInput = {
  id?: string
  AND?: Array<CommentWhereInput>
  OR?: Array<CommentWhereInput>
  NOT?: CommentWhereInput
  content?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
    comment: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Comment | null>
      findMany: (args?: {
        where?: CommentWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Comment[]>
      create: (args: {
        data: CommentCreateInput
      }) => Promise<Comment | null>
      update: (args: {
        where: { id: string }
        data: CommentUpdateInput
      }) => Promise<Comment | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Comment | null>
      count: (args?: {
        where?: CommentWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in CreateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type Post = {
  id: string
  title: string | null
  authorId: string | null
  author: User | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

export type User = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in UpdateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type Post = {
  id: string
  title: string | null
  authorId: string | null
  author: User | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

export type User = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in types 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

export type User = {
  id: string
  name: string | null
  posts: Post[]
  createdAt: Date
  updatedAt: Date
}

export type UserCreateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }> }
}

export type UserUpdateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }>, disconnect: Array<{ id: string }> }
}

export type UserWhereInput = {
  id?: string
  AND?: Array<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: UserWhereInput
  name?: { equals?: string, not?: string }
}

export type Post = {
  id: string
  title: string | null
  authorId: string | null
  author: User | null
  createdAt: Date
  updatedAt: Date
}

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: string
  AND?: Array<PostWhereInput>
  OR?: Array<PostWhereInput>
  NOT?: PostWhereInput
  title?: { equals?: string, not?: string }
}

export type Context = {
  db: {
    user: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<User | null>
      findMany: (args?: {
        where?: UserWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<User[]>
      create: (args: {
        data: UserCreateInput
      }) => Promise<User | null>
      update: (args: {
        where: { id: string }
        data: UserUpdateInput
      }) => Promise<User | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<User | null>
      count: (args?: {
        where?: UserWhereInput
      }) => Promise<number>
    }
    post: {
      findUnique: (args: {
        where: { id: string }
        include?: any
      }) => Promise<Post | null>
      findMany: (args?: {
        where?: PostWhereInput
        take?: number
        skip?: number
        include?: any
      }) => Promise<Post[]>
      create: (args: {
        data: PostCreateInput
      }) => Promise<Post | null>
      update: (args: {
        where: { id: string }
        data: PostUpdateInput
      }) => Promise<Post | null>
      delete: (args: {
        where: { id: string }
      }) => Promise<Post | null>
      count: (args?: {
        where?: PostWhereInput
      }) => Promise<number>
    }
  }
  session: any
  prisma: any  // Your PrismaClient instance
}"
`;
