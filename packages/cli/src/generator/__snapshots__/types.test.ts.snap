// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Types Generator > generateTypes > should generate Context type with all operations 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate CreateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  content?: Prisma.StringFilter<"Post"> | string
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.PostGetPayload<T> &
  {}

/**
 * Default args type for Post with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom FindManyArgs for Post with virtual field support
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom CreateArgs for Post with virtual field support
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom UpdateArgs for Post with virtual field support
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom DeleteArgs for Post with virtual field support
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post'
> & {
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate Include type with virtual fields for models with relationships 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  postCount: number
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  posts?: PostOutput[]
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }> }
}

export type UserUpdateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }>, disconnect: Array<{ id: string }> }
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
  posts?: {
    some?: PostWhereInput
    every?: PostWhereInput
    none?: PostWhereInput
  }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,
 *   postCount: true, // Virtual field
 * } satisfies UserSelect
 */
export type UserSelect = Prisma.UserSelect & {
  postCount?: boolean
  posts?: boolean | PostDefaultArgs
}

/**
 * Include type for User with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,
 *   postCount: true, // Virtual field
 * } satisfies UserInclude
 */
export type UserInclude = Prisma.UserInclude & {
  postCount?: boolean
  posts?: boolean | PostDefaultArgs
}

/**
 * GetPayload type for User with virtual and transformed field support
 * Extends Prisma's GetPayload to include virtual and transformed fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   postCount: true, // Virtual field
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.UserGetPayload<T>, 'posts'> &
  {
    posts?:
      T extends { select: any }
        ? 'posts' extends keyof T['select']
          ? T['select']['posts'] extends true
            ? Post[]
            : T['select']['posts'] extends { select: any }
              ? PostGetPayload<{ select: T['select']['posts']['select'] }>[]
              : T['select']['posts'] extends { include: any }
                ? PostGetPayload<{ include: T['select']['posts']['include'] }>[]
                : Post[]
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? Post[]
            : 'posts' extends keyof T['include']
              ? T['include']['posts'] extends true
                ? Post[]
                : T['include']['posts'] extends { select: any }
                  ? PostGetPayload<{ select: T['include']['posts']['select'] }>[]
                  : T['include']['posts'] extends { include: any }
                    ? PostGetPayload<{ include: T['include']['posts']['include'] }>[]
                    : Post[]
              : never
          : Post[]
  } &
  (
    T extends { select: any }
      ? T['select'] extends true
        ? UserVirtualFields
        : {
            [K in keyof UserVirtualFields as K extends keyof T['select']
              ? T['select'][K] extends true
                ? K
                : never
              : never]: UserVirtualFields[K]
          }
      : T extends { include: any }
        ? T['include'] extends true
          ? UserVirtualFields
          : {
              [K in keyof UserVirtualFields as K extends keyof T['include']
                ? T['include'][K] extends true
                  ? K
                  : never
                : never]: UserVirtualFields[K]
            }
        : UserVirtualFields
  )

/**
 * Default args type for User with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support in nested relationships
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom FindManyArgs for User with virtual field support in nested relationships
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom CreateArgs for User with virtual field support in nested relationships
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom UpdateArgs for User with virtual field support in nested relationships
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom DeleteArgs for User with virtual field support in nested relationships
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  author?: UserWhereInput | null
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,

 * } satisfies PostSelect
 */
export type PostSelect = Prisma.PostSelect & {
  author?: boolean | UserDefaultArgs
}

/**
 * Include type for Post with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,

 * } satisfies PostInclude
 */
export type PostInclude = Prisma.PostInclude & {
  author?: boolean | UserDefaultArgs
}

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.PostGetPayload<T>, 'author'> &
  {
    author?:
      T extends { select: any }
        ? 'author' extends keyof T['select']
          ? T['select']['author'] extends true
            ? User
            : T['select']['author'] extends { select: any }
              ? UserGetPayload<{ select: T['select']['author']['select'] }>
              : T['select']['author'] extends { include: any }
                ? UserGetPayload<{ include: T['select']['author']['include'] }>
                : User
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? User
            : 'author' extends keyof T['include']
              ? T['include']['author'] extends true
                ? User
                : T['include']['author'] extends { select: any }
                  ? UserGetPayload<{ select: T['include']['author']['select'] }>
                  : T['include']['author'] extends { include: any }
                    ? UserGetPayload<{ include: T['include']['author']['include'] }>
                    : User
              : never
          : User
  } &
  {}

/**
 * Default args type for Post with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support in nested relationships
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindManyArgs for Post with virtual field support in nested relationships
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom CreateArgs for Post with virtual field support in nested relationships
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom UpdateArgs for Post with virtual field support in nested relationships
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DeleteArgs for Post with virtual field support in nested relationships
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user' | 'post'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate Select and GetPayload types with virtual fields 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  fullName: string
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  firstName: string
  lastName: string
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  firstName: string
  lastName: string
}

export type UserUpdateInput = {
  firstName?: string
  lastName?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  firstName?: Prisma.StringFilter<"User"> | string
  lastName?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,
 *   fullName: true, // Virtual field
 * } satisfies UserSelect
 */
export type UserSelect = Prisma.UserSelect & {
  fullName?: boolean
}

/**
 * GetPayload type for User with virtual and transformed field support
 * Extends Prisma's GetPayload to include virtual and transformed fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   fullName: true, // Virtual field
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  (
    T extends { select: any }
      ? T['select'] extends true
        ? UserVirtualFields
        : {
            [K in keyof UserVirtualFields as K extends keyof T['select']
              ? T['select'][K] extends true
                ? K
                : never
              : never]: UserVirtualFields[K]
          }
      : T extends { include: any }
        ? T['include'] extends true
          ? UserVirtualFields
          : {
              [K in keyof UserVirtualFields as K extends keyof T['include']
                ? T['include'][K] extends true
                  ? K
                  : never
                : never]: UserVirtualFields[K]
            }
        : UserVirtualFields
  )

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate UpdateInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title: string
  content?: string
}

export type PostUpdateInput = {
  title?: string
  content?: string
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  content?: Prisma.StringFilter<"Post"> | string
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.PostGetPayload<T> &
  {}

/**
 * Default args type for Post with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom FindManyArgs for Post with virtual field support
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom CreateArgs for Post with virtual field support
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom UpdateArgs for Post with virtual field support
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom DeleteArgs for Post with virtual field support
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post'
> & {
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate WhereInput type 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate type definitions for basic model 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name: string
  email: string
}

export type UserUpdateInput = {
  name?: string
  email?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
  email?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should generate types for multiple lists 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
}

export type PostUpdateInput = {
  title?: string
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type PostSelect = Prisma.PostSelect

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.PostGetPayload<T> &
  {}

/**
 * Default args type for Post with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom FindManyArgs for Post with virtual field support
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom CreateArgs for Post with virtual field support
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom UpdateArgs for Post with virtual field support
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Custom DeleteArgs for Post with virtual field support
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select'> & {
  select?: PostSelect | null
}

/**
 * Virtual fields for Comment - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type CommentVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Comment - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type CommentTransformedFields = {
  // No transformed fields defined
}

export type CommentOutput = {
  id: string
  content: string | null
  createdAt: Date
  updatedAt: Date
} & CommentVirtualFields

export type Comment = CommentOutput

export type CommentCreateInput = {
  content?: string
}

export type CommentUpdateInput = {
  content?: string
}

export type CommentWhereInput = {
  id?: Prisma.StringFilter<"Comment"> | string
  AND?: CommentWhereInput | CommentWhereInput[]
  OR?: CommentWhereInput[]
  NOT?: CommentWhereInput | CommentWhereInput[]
  content?: Prisma.StringFilter<"Comment"> | string
}

/**
 * Hook types for Comment list
 * Properly typed to use Prisma's generated input types
 */
export type CommentHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.CommentCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.CommentUpdateInput
        item: Comment
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.CommentCreateInput | Prisma.CommentUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.CommentCreateInput | Prisma.CommentUpdateInput
    item?: Comment
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Comment
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type CommentSelect = Prisma.CommentSelect

/**
 * GetPayload type for Comment
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies CommentSelect
 *
 * type Result = CommentGetPayload<{ select: typeof select }>
 */
export type CommentGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.CommentGetPayload<T> &
  {}

/**
 * Default args type for Comment with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type CommentDefaultArgs = {
  select?: CommentSelect | null
}

/**
 * Custom FindUniqueArgs for Comment with virtual field support
 */
export type CommentFindUniqueArgs = Omit<Prisma.CommentFindUniqueArgs, 'select'> & {
  select?: CommentSelect | null
}

/**
 * Custom FindManyArgs for Comment with virtual field support
 */
export type CommentFindManyArgs = Omit<Prisma.CommentFindManyArgs, 'select'> & {
  select?: CommentSelect | null
}

/**
 * Custom CreateArgs for Comment with virtual field support
 */
export type CommentCreateArgs = Omit<Prisma.CommentCreateArgs, 'select'> & {
  select?: CommentSelect | null
}

/**
 * Custom UpdateArgs for Comment with virtual field support
 */
export type CommentUpdateArgs = Omit<Prisma.CommentUpdateArgs, 'select'> & {
  select?: CommentSelect | null
}

/**
 * Custom DeleteArgs for Comment with virtual field support
 */
export type CommentDeleteArgs = Omit<Prisma.CommentDeleteArgs, 'select'> & {
  select?: CommentSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user' | 'post' | 'comment'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  comment: {
    findUnique: <T extends CommentFindUniqueArgs>(
      args: Prisma.SelectSubset<T, CommentFindUniqueArgs>
    ) => Promise<CommentGetPayload<T> | null>
    findMany: <T extends CommentFindManyArgs>(
      args?: Prisma.SelectSubset<T, CommentFindManyArgs>
    ) => Promise<Array<CommentGetPayload<T>>>
    create: <T extends CommentCreateArgs>(
      args: Prisma.SelectSubset<T, CommentCreateArgs>
    ) => Promise<CommentGetPayload<T>>
    update: <T extends CommentUpdateArgs>(
      args: Prisma.SelectSubset<T, CommentUpdateArgs>
    ) => Promise<CommentGetPayload<T> | null>
    delete: <T extends CommentDeleteArgs>(
      args: Prisma.SelectSubset<T, CommentDeleteArgs>
    ) => Promise<CommentGetPayload<T> | null>
    count: (args?: Prisma.CommentCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in CreateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  author?: UserWhereInput | null
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,

 * } satisfies PostSelect
 */
export type PostSelect = Prisma.PostSelect & {
  author?: boolean | UserDefaultArgs
}

/**
 * Include type for Post with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,

 * } satisfies PostInclude
 */
export type PostInclude = Prisma.PostInclude & {
  author?: boolean | UserDefaultArgs
}

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.PostGetPayload<T>, 'author'> &
  {
    author?:
      T extends { select: any }
        ? 'author' extends keyof T['select']
          ? T['select']['author'] extends true
            ? User
            : T['select']['author'] extends { select: any }
              ? UserGetPayload<{ select: T['select']['author']['select'] }>
              : T['select']['author'] extends { include: any }
                ? UserGetPayload<{ include: T['select']['author']['include'] }>
                : User
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? User
            : 'author' extends keyof T['include']
              ? T['include']['author'] extends true
                ? User
                : T['include']['author'] extends { select: any }
                  ? UserGetPayload<{ select: T['include']['author']['select'] }>
                  : T['include']['author'] extends { include: any }
                    ? UserGetPayload<{ include: T['include']['author']['include'] }>
                    : User
              : never
          : User
  } &
  {}

/**
 * Default args type for Post with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support in nested relationships
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindManyArgs for Post with virtual field support in nested relationships
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom CreateArgs for Post with virtual field support in nested relationships
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom UpdateArgs for Post with virtual field support in nested relationships
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DeleteArgs for Post with virtual field support in nested relationships
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post' | 'user'
> & {
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in UpdateInput 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  author?: UserWhereInput | null
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,

 * } satisfies PostSelect
 */
export type PostSelect = Prisma.PostSelect & {
  author?: boolean | UserDefaultArgs
}

/**
 * Include type for Post with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,

 * } satisfies PostInclude
 */
export type PostInclude = Prisma.PostInclude & {
  author?: boolean | UserDefaultArgs
}

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.PostGetPayload<T>, 'author'> &
  {
    author?:
      T extends { select: any }
        ? 'author' extends keyof T['select']
          ? T['select']['author'] extends true
            ? User
            : T['select']['author'] extends { select: any }
              ? UserGetPayload<{ select: T['select']['author']['select'] }>
              : T['select']['author'] extends { include: any }
                ? UserGetPayload<{ include: T['select']['author']['include'] }>
                : User
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? User
            : 'author' extends keyof T['include']
              ? T['include']['author'] extends true
                ? User
                : T['include']['author'] extends { select: any }
                  ? UserGetPayload<{ select: T['include']['author']['select'] }>
                  : T['include']['author'] extends { include: any }
                    ? UserGetPayload<{ include: T['include']['author']['include'] }>
                    : User
              : never
          : User
  } &
  {}

/**
 * Default args type for Post with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support in nested relationships
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindManyArgs for Post with virtual field support in nested relationships
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom CreateArgs for Post with virtual field support in nested relationships
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom UpdateArgs for Post with virtual field support in nested relationships
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DeleteArgs for Post with virtual field support in nested relationships
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
}

export type UserUpdateInput = {
  name?: string
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User
 * No virtual fields defined, uses Prisma's Select type directly
 */
export type UserSelect = Prisma.UserSelect

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Prisma.UserGetPayload<T> &
  {}

/**
 * Default args type for User with custom Select support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom FindManyArgs for User with virtual field support
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom CreateArgs for User with virtual field support
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom UpdateArgs for User with virtual field support
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DeleteArgs for User with virtual field support
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select'> & {
  select?: UserSelect | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'post' | 'user'
> & {
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;

exports[`Types Generator > generateTypes > should handle relationship fields in types 1`] = `
"/**
 * Generated types from OpenSaas configuration
 * DO NOT EDIT - This file is automatically generated
 */

import type { Session as OpensaasSession, StorageUtils, ServerActionProps, AccessControlledDB, AccessContext } from '@opensaas/stack-core'
import type { PrismaClient, Prisma } from './prisma-client/client'
import type { PluginServices } from './plugin-types'

/**
 * Virtual fields for User - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type UserVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for User - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type UserTransformedFields = {
  // No transformed fields defined
}

export type UserOutput = {
  id: string
  name: string | null
  posts?: PostOutput[]
  createdAt: Date
  updatedAt: Date
} & UserVirtualFields

export type User = UserOutput

export type UserCreateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }> }
}

export type UserUpdateInput = {
  name?: string
  posts?: { connect: Array<{ id: string }>, disconnect: Array<{ id: string }> }
}

export type UserWhereInput = {
  id?: Prisma.StringFilter<"User"> | string
  AND?: UserWhereInput | UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput | UserWhereInput[]
  name?: Prisma.StringFilter<"User"> | string
  posts?: {
    some?: PostWhereInput
    every?: PostWhereInput
    none?: PostWhereInput
  }
}

/**
 * Hook types for User list
 * Properly typed to use Prisma's generated input types
 */
export type UserHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.UserCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.UserUpdateInput
        item: User
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.UserCreateInput | Prisma.UserUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.UserCreateInput | Prisma.UserUpdateInput
    item?: User
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for User with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,

 * } satisfies UserSelect
 */
export type UserSelect = Prisma.UserSelect & {
  posts?: boolean | PostDefaultArgs
}

/**
 * Include type for User with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,

 * } satisfies UserInclude
 */
export type UserInclude = Prisma.UserInclude & {
  posts?: boolean | PostDefaultArgs
}

/**
 * GetPayload type for User
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies UserSelect
 *
 * type Result = UserGetPayload<{ select: typeof select }>
 */
export type UserGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.UserGetPayload<T>, 'posts'> &
  {
    posts?:
      T extends { select: any }
        ? 'posts' extends keyof T['select']
          ? T['select']['posts'] extends true
            ? Post[]
            : T['select']['posts'] extends { select: any }
              ? PostGetPayload<{ select: T['select']['posts']['select'] }>[]
              : T['select']['posts'] extends { include: any }
                ? PostGetPayload<{ include: T['select']['posts']['include'] }>[]
                : Post[]
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? Post[]
            : 'posts' extends keyof T['include']
              ? T['include']['posts'] extends true
                ? Post[]
                : T['include']['posts'] extends { select: any }
                  ? PostGetPayload<{ select: T['include']['posts']['select'] }>[]
                  : T['include']['posts'] extends { include: any }
                    ? PostGetPayload<{ include: T['include']['posts']['include'] }>[]
                    : Post[]
              : never
          : Post[]
  } &
  {}

/**
 * Default args type for User with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type UserDefaultArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom FindUniqueArgs for User with virtual field support in nested relationships
 */
export type UserFindUniqueArgs = Omit<Prisma.UserFindUniqueArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom FindManyArgs for User with virtual field support in nested relationships
 */
export type UserFindManyArgs = Omit<Prisma.UserFindManyArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom CreateArgs for User with virtual field support in nested relationships
 */
export type UserCreateArgs = Omit<Prisma.UserCreateArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom UpdateArgs for User with virtual field support in nested relationships
 */
export type UserUpdateArgs = Omit<Prisma.UserUpdateArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Custom DeleteArgs for User with virtual field support in nested relationships
 */
export type UserDeleteArgs = Omit<Prisma.UserDeleteArgs, 'select' | 'include'> & {
  select?: UserSelect | null
  include?: UserInclude | null
}

/**
 * Virtual fields for Post - computed fields not in database
 * These are added to query results via resolveOutput hooks
 */
export type PostVirtualFields = {
  // No virtual fields defined
}

/**
 * Transformed fields for Post - fields with resultExtension transformations
 * These override Prisma's base types with transformed types via result extensions
 */
export type PostTransformedFields = {
  // No transformed fields defined
}

export type PostOutput = {
  id: string
  title: string | null
  authorId: string | null
  author?: UserOutput | null
  createdAt: Date
  updatedAt: Date
} & PostVirtualFields

export type Post = PostOutput

export type PostCreateInput = {
  title?: string
  author?: { connect: { id: string } }
}

export type PostUpdateInput = {
  title?: string
  author?: { connect: { id: string } } | { disconnect: true }
}

export type PostWhereInput = {
  id?: Prisma.StringFilter<"Post"> | string
  AND?: PostWhereInput | PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput | PostWhereInput[]
  title?: Prisma.StringFilter<"Post"> | string
  author?: UserWhereInput | null
}

/**
 * Hook types for Post list
 * Properly typed to use Prisma's generated input types
 */
export type PostHooks = {
  resolveInput?: (args:
    | {
        operation: 'create'
        resolvedData: Prisma.PostCreateInput
        item: undefined
        context: import('@opensaas/stack-core').AccessContext
      }
    | {
        operation: 'update'
        resolvedData: Prisma.PostUpdateInput
        item: Post
        context: import('@opensaas/stack-core').AccessContext
      }
  ) => Promise<Prisma.PostCreateInput | Prisma.PostUpdateInput>
  validateInput?: (args: {
    operation: 'create' | 'update'
    resolvedData: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
    addValidationError: (msg: string) => void
  }) => Promise<void>
  beforeOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
  afterOperation?: (args: {
    operation: 'create' | 'update' | 'delete'
    resolvedData?: Prisma.PostCreateInput | Prisma.PostUpdateInput
    item?: Post
    context: import('@opensaas/stack-core').AccessContext
  }) => Promise<void>
}

/**
 * Select type for Post with virtual field support
 * Extends Prisma's Select type to include virtual fields
 * and supports custom Select types in nested relationships
 * Use this type when selecting fields to enable virtual field selection
 *
 * @example
 * const select = {
 *   id: true,
 *   name: true,

 * } satisfies PostSelect
 */
export type PostSelect = Prisma.PostSelect & {
  author?: boolean | UserDefaultArgs
}

/**
 * Include type for Post with virtual field support
 * Extends Prisma's Include type to include virtual fields
 * and supports custom Include types in nested relationships
 * Use this type when including relationships to enable virtual field selection
 *
 * @example
 * const include = {
 *   author: true,

 * } satisfies PostInclude
 */
export type PostInclude = Prisma.PostInclude & {
  author?: boolean | UserDefaultArgs
}

/**
 * GetPayload type for Post
 * Wraps Prisma's GetPayload to ensure nested relations support virtual fields
 * Use this type to get properly typed results with virtual fields
 *
 * @example
 * const select = {
 *   id: true,
 *   // Relations can include virtual fields from related lists
 * } satisfies PostSelect
 *
 * type Result = PostGetPayload<{ select: typeof select }>
 */
export type PostGetPayload<T extends { select?: any; include?: any } = {}> =
  Omit<Prisma.PostGetPayload<T>, 'author'> &
  {
    author?:
      T extends { select: any }
        ? 'author' extends keyof T['select']
          ? T['select']['author'] extends true
            ? User
            : T['select']['author'] extends { select: any }
              ? UserGetPayload<{ select: T['select']['author']['select'] }>
              : T['select']['author'] extends { include: any }
                ? UserGetPayload<{ include: T['select']['author']['include'] }>
                : User
          : never
        : T extends { include: any }
          ? T['include'] extends true
            ? User
            : 'author' extends keyof T['include']
              ? T['include']['author'] extends true
                ? User
                : T['include']['author'] extends { select: any }
                  ? UserGetPayload<{ select: T['include']['author']['select'] }>
                  : T['include']['author'] extends { include: any }
                    ? UserGetPayload<{ include: T['include']['author']['include'] }>
                    : User
              : never
          : User
  } &
  {}

/**
 * Default args type for Post with custom Select/Include support
 * Used in nested relationship selections to support virtual fields
 */
export type PostDefaultArgs = {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindUniqueArgs for Post with virtual field support in nested relationships
 */
export type PostFindUniqueArgs = Omit<Prisma.PostFindUniqueArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom FindManyArgs for Post with virtual field support in nested relationships
 */
export type PostFindManyArgs = Omit<Prisma.PostFindManyArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom CreateArgs for Post with virtual field support in nested relationships
 */
export type PostCreateArgs = Omit<Prisma.PostCreateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom UpdateArgs for Post with virtual field support in nested relationships
 */
export type PostUpdateArgs = Omit<Prisma.PostUpdateArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DeleteArgs for Post with virtual field support in nested relationships
 */
export type PostDeleteArgs = Omit<Prisma.PostDeleteArgs, 'select' | 'include'> & {
  select?: PostSelect | null
  include?: PostInclude | null
}

/**
 * Custom DB type that uses Prisma's conditional types with virtual and transformed field support
 * Types change based on select/include - relationships only present when explicitly included
 * Virtual fields and transformed fields are added to the base model type
 */
export type CustomDB = Omit<AccessControlledDB<PrismaClient>, 
  'user' | 'post'
> & {
  user: {
    findUnique: <T extends UserFindUniqueArgs>(
      args: Prisma.SelectSubset<T, UserFindUniqueArgs>
    ) => Promise<UserGetPayload<T> | null>
    findMany: <T extends UserFindManyArgs>(
      args?: Prisma.SelectSubset<T, UserFindManyArgs>
    ) => Promise<Array<UserGetPayload<T>>>
    create: <T extends UserCreateArgs>(
      args: Prisma.SelectSubset<T, UserCreateArgs>
    ) => Promise<UserGetPayload<T>>
    update: <T extends UserUpdateArgs>(
      args: Prisma.SelectSubset<T, UserUpdateArgs>
    ) => Promise<UserGetPayload<T> | null>
    delete: <T extends UserDeleteArgs>(
      args: Prisma.SelectSubset<T, UserDeleteArgs>
    ) => Promise<UserGetPayload<T> | null>
    count: (args?: Prisma.UserCountArgs) => Promise<number>
  }
  post: {
    findUnique: <T extends PostFindUniqueArgs>(
      args: Prisma.SelectSubset<T, PostFindUniqueArgs>
    ) => Promise<PostGetPayload<T> | null>
    findMany: <T extends PostFindManyArgs>(
      args?: Prisma.SelectSubset<T, PostFindManyArgs>
    ) => Promise<Array<PostGetPayload<T>>>
    create: <T extends PostCreateArgs>(
      args: Prisma.SelectSubset<T, PostCreateArgs>
    ) => Promise<PostGetPayload<T>>
    update: <T extends PostUpdateArgs>(
      args: Prisma.SelectSubset<T, PostUpdateArgs>
    ) => Promise<PostGetPayload<T> | null>
    delete: <T extends PostDeleteArgs>(
      args: Prisma.SelectSubset<T, PostDeleteArgs>
    ) => Promise<PostGetPayload<T> | null>
    count: (args?: Prisma.PostCountArgs) => Promise<number>
  }
}

/**
 * Base context type for services that only need database and session access
 * Compatible with both AccessContext (from hooks) and Context (from server actions)
 * Use this type for services that should work in both contexts
 */
export type BaseContext<TSession extends OpensaasSession = OpensaasSession> = Omit<AccessContext<PrismaClient>, 'db' | 'session'> & {
  db: CustomDB
  session: TSession
}

/**
 * Full context type with server action capabilities and virtual field typing
 * Extends BaseContext and adds serverAction and sudo methods
 * Use this type in server actions and components that need full context capabilities
 */
export type Context<TSession extends OpensaasSession = OpensaasSession> = BaseContext<TSession> & {
  serverAction: (props: ServerActionProps) => Promise<unknown>
  sudo: () => Context<TSession>
}"
`;
