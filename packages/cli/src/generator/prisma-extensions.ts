import type { OpenSaasConfig, FieldConfig } from '@opensaas/stack-core'
import * as fs from 'fs'
import * as path from 'path'

/**
 * Generate Prisma result extensions configuration
 * This creates a Prisma client extension that calls field resolveOutput hooks
 */
export function generatePrismaExtensions(config: OpenSaasConfig): string {
  const lines: string[] = []

  // Add header comment
  lines.push('/**')
  lines.push(' * Generated Prisma result extensions from OpenSaas configuration')
  lines.push(' * DO NOT EDIT - This file is automatically generated')
  lines.push(' */')
  lines.push('')

  // Add imports
  lines.push("import { Prisma } from './prisma-client/client'")
  lines.push("import configOrPromise from '../opensaas.config'")
  lines.push('')

  // Resolve config synchronously if possible (will be resolved by context.ts anyway)
  lines.push('// Resolve config - may be a promise if plugins are present')
  lines.push('let resolvedConfig: any = null')
  lines.push('const configPromise = Promise.resolve(configOrPromise)')
  lines.push('configPromise.then(cfg => { resolvedConfig = cfg })')
  lines.push('')

  // Check if any fields have result extensions or are virtual
  let hasExtensions = false
  for (const listConfig of Object.values(config.lists)) {
    for (const fieldConfig of Object.values(listConfig.fields)) {
      if (fieldConfig.resultExtension || fieldConfig.virtual) {
        hasExtensions = true
        break
      }
    }
    if (hasExtensions) break
  }

  if (!hasExtensions) {
    // No extensions needed - export a no-op
    lines.push('/**')
    lines.push(' * No result extensions configured')
    lines.push(' */')
    lines.push('export const prismaExtensions = {}')
    lines.push('')
    return lines.join('\n')
  }

  // Generate result extensions
  lines.push('/**')
  lines.push(' * Prisma result extensions for field transformations and virtual fields')
  lines.push(' * Delegates to field resolveOutput hooks from config for runtime transformations')
  lines.push(' */')
  lines.push('export const prismaExtensions = Prisma.defineExtension({')
  lines.push('  result: {')

  // Generate extensions for each list
  for (const [listName, listConfig] of Object.entries(config.lists)) {
    // Include both fields with resultExtension AND virtual fields
    const fieldsWithExtensions: Array<[string, FieldConfig]> = Object.entries(
      listConfig.fields,
    ).filter(([_, config]) => config.resultExtension || config.virtual)

    if (fieldsWithExtensions.length === 0) continue

    const modelKey = listName.charAt(0).toLowerCase() + listName.slice(1) // camelCase

    lines.push(`    ${modelKey}: {`)

    for (const [fieldName, fieldConfig] of fieldsWithExtensions) {
      const isVirtual = fieldConfig.virtual

      lines.push(`      ${fieldName}: {`)

      if (isVirtual) {
        // Virtual fields don't need database fields - they compute from the full item
        lines.push(`        needs: {},`)
      } else {
        // Non-virtual fields need their database value
        lines.push(`        needs: { ${fieldName}: true },`)
      }

      lines.push(`        compute: (${modelKey}) => {`)

      if (!isVirtual) {
        // For non-virtual fields, get the database value and check nullability
        lines.push(`          const value = ${modelKey}.${fieldName}`)
        lines.push(`          if (value === null || value === undefined) {`)
        lines.push(`            return undefined`)
        lines.push(`          }`)
      }

      lines.push(`          // Call field's resolveOutput hook if available (synchronously)`)
      lines.push(`          if (!resolvedConfig) {`)
      lines.push(
        `            // Config not yet resolved - return undefined for virtual, value for regular`,
      )
      if (isVirtual) {
        lines.push(`            return undefined`)
      } else {
        lines.push(`            return value`)
      }
      lines.push(`          }`)
      lines.push(
        `          const fieldConfig = resolvedConfig.lists['${listName}'].fields['${fieldName}']`,
      )
      lines.push(`          if (fieldConfig.hooks?.resolveOutput) {`)
      lines.push(`            return fieldConfig.hooks.resolveOutput({`)
      lines.push(`              operation: 'query',`)
      if (isVirtual) {
        lines.push(`              value: undefined, // Virtual fields have no stored value`)
      } else {
        lines.push(`              value,`)
      }
      lines.push(`              item: ${modelKey},`)
      lines.push(`              listKey: '${listName}',`)
      lines.push(`              fieldName: '${fieldName}',`)
      lines.push(
        `              context: null as any, // Extension context doesn't have full context`,
      )
      lines.push(`            })`)
      lines.push(`          }`)
      if (isVirtual) {
        lines.push(`          return undefined`)
      } else {
        lines.push(`          return value`)
      }
      lines.push(`        },`)
      lines.push(`      },`)
    }

    lines.push(`    },`)
  }

  lines.push('  },')
  lines.push('})')
  lines.push('')

  return lines.join('\n')
}

/**
 * Write Prisma extensions configuration to file
 */
export function writePrismaExtensions(config: OpenSaasConfig, outputPath: string): void {
  const extensions = generatePrismaExtensions(config)

  // Ensure directory exists
  const dir = path.dirname(outputPath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }

  fs.writeFileSync(outputPath, extensions, 'utf-8')
}
