import { config, list } from '@opensaas/stack-core'
import { text, relationship, select, timestamp } from '@opensaas/stack-core/fields'
import { authPlugin } from '@opensaas/stack-auth'
import type { AccessControl } from '@opensaas/stack-core'
import type { Lists } from '@/.opensaas/lists'
import { PrismaBetterSqlite3 } from '@prisma/adapter-better-sqlite3'

/**
 * Access control helpers
 */

// Check if user is signed in
const isSignedIn: AccessControl = ({ session }) => {
  return !!session
}

// Check if user is the author of a post
const isAuthor: AccessControl = ({ session }) => {
  if (!session) return false
  return {
    authorId: { equals: session.userId },
  }
}

/**
 * OpenSaas Configuration with Better-Auth
 */
export default config({
  plugins: [
    authPlugin({
      // Enable email/password authentication
      emailAndPassword: {
        enabled: true,
        minPasswordLength: 8,
        requireConfirmation: true,
      },

      // Enable password reset
      passwordReset: {
        enabled: true,
      },

      // Configure session fields
      sessionFields: ['userId', 'email', 'name'],

      // Extend User list with custom fields
      extendUserList: {
        fields: {
          // Add a posts relationship
          posts: relationship({
            ref: 'Post.author',
            many: true,
          }),
        },
      },
    }),
  ],

  db: {
    provider: 'sqlite',
    prismaClientConstructor: (PrismaClient) => {
      const adapter = new PrismaBetterSqlite3({ url: process.env.DATABASE_URL || './dev.db' })
      return new PrismaClient({ adapter })
    },
  },

  lists: {
    // User list is auto-generated by authPlugin, but we can reference it
    Post: list<Lists.Post.TypeInfo>({
      fields: {
        title: text({
          validation: { isRequired: true },
          access: {
            read: () => true,
            create: isSignedIn,
            update: isAuthor,
          },
        }),
        slug: text({
          validation: { isRequired: true },
          isIndexed: 'unique',
        }),
        content: text({
          ui: { displayMode: 'textarea' },
          access: {
            read: () => true,
            create: isSignedIn,
            update: isAuthor,
          },
        }),
        internalNotes: text({
          ui: { displayMode: 'textarea' },
          // Only the author can read/write internal notes
          access: {
            read: isAuthor,
            create: isAuthor,
            update: isAuthor,
          },
        }),
        status: select({
          options: [
            { label: 'Draft', value: 'draft' },
            { label: 'Published', value: 'published' },
          ],
          defaultValue: 'draft',
          ui: { displayMode: 'segmented-control' },
        }),
        publishedAt: timestamp(),
        author: relationship({
          ref: 'User.posts',
        }),
      },
      access: {
        operation: {
          // Non-authenticated users can only see published posts
          // Authenticated users can see all posts
          query: ({ session }) => {
            if (!session) {
              return { status: { equals: 'published' } }
            }
            return true
          },
          // Must be signed in to create
          create: isSignedIn,
          // Only author can update
          update: isAuthor,
          // Only author can delete
          delete: isAuthor,
        },
      },
      hooks: {
        // Auto-set publishedAt when status changes to published
        resolveInput: async ({ operation, resolvedData, item }) => {
          // If changing status to published and publishedAt isn't set yet
          if (operation === 'create' && resolvedData?.status === 'published') {
            return {
              ...resolvedData,
              publishedAt: new Date(),
            }
          } else if (
            operation === 'update' &&
            resolvedData?.status === 'published' &&
            !item?.publishedAt
          ) {
            return {
              ...resolvedData,
              publishedAt: new Date(),
            }
          }
          return { ...resolvedData }
        },
        // Example validation: title must not contain "spam"
        validateInput: async ({ resolvedData, addValidationError }) => {
          if (
            resolvedData &&
            'title' in resolvedData &&
            resolvedData.title &&
            typeof resolvedData.title === 'string' &&
            resolvedData.title.toLowerCase().includes('spam')
          ) {
            addValidationError('Title cannot contain the word "spam"')
          }
        },
      },
    }),
  },

  ui: {
    basePath: '/admin',
  },
})
