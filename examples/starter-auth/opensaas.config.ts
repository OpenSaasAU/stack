import { config, list } from '@opensaas/stack-core'
import { text, relationship, select, timestamp } from '@opensaas/stack-core/fields'
import { withAuth, authConfig } from '@opensaas/stack-auth'
import type { AccessControl } from '@opensaas/stack-core'
import type { Post } from '@/.opensaas/types'

/**
 * Access control helpers
 */

// Check if user is signed in
const isSignedIn: AccessControl = ({ session }) => {
  return !!session
}

// Check if user is the author of a post
const isAuthor: AccessControl = ({ session }) => {
  if (!session) return false
  return {
    authorId: { equals: session.userId },
  }
}

/**
 * OpenSaas Configuration with Better-Auth
 */
export default withAuth(
  config({
    db: {
      provider: 'sqlite',
      url: process.env.DATABASE_URL || 'file:./dev.db',
    },

    lists: {
      // User list is auto-generated by withAuth, but we can reference it
      Post: list<Post>({
        fields: {
          title: text({
            validation: { isRequired: true },
            access: {
              read: () => true,
              create: isSignedIn,
              update: isAuthor,
            },
          }),
          slug: text({
            validation: { isRequired: true },
            isIndexed: 'unique',
          }),
          content: text({
            ui: { displayMode: 'textarea' },
            access: {
              read: () => true,
              create: isSignedIn,
              update: isAuthor,
            },
          }),
          internalNotes: text({
            ui: { displayMode: 'textarea' },
            // Only the author can read/write internal notes
            access: {
              read: isAuthor,
              create: isAuthor,
              update: isAuthor,
            },
          }),
          status: select({
            options: [
              { label: 'Draft', value: 'draft' },
              { label: 'Published', value: 'published' },
            ],
            defaultValue: 'draft',
            ui: { displayMode: 'segmented-control' },
          }),
          publishedAt: timestamp(),
          author: relationship({
            ref: 'User.posts',
          }),
        },
        access: {
          operation: {
            // Non-authenticated users can only see published posts
            // Authenticated users can see all posts
            query: ({ session }) => {
              if (!session) {
                return { status: { equals: 'published' } }
              }
              return true
            },
            // Must be signed in to create
            create: isSignedIn,
            // Only author can update
            update: isAuthor,
            // Only author can delete
            delete: isAuthor,
          },
        },
        hooks: {
          // Auto-set publishedAt when status changes to published
          resolveInput: async ({ operation, resolvedData, item }) => {
            // If changing status to published and publishedAt isn't set yet
            if (
              resolvedData?.status === 'published' &&
              (!item?.publishedAt || operation === 'create')
            ) {
              return {
                ...resolvedData,
                publishedAt: new Date(),
              }
            }
            return { ...resolvedData }
          },
          // Example validation: title must not contain "spam"
          validateInput: async ({ resolvedData, addValidationError }) => {
            if (resolvedData?.title && resolvedData.title.toLowerCase().includes('spam')) {
              addValidationError('Title cannot contain the word "spam"')
            }
          },
        },
      }),
    },

    ui: {
      basePath: '/admin',
    },
  }),
  authConfig({
    // Enable email/password authentication
    emailAndPassword: {
      enabled: true,
      minPasswordLength: 8,
      requireConfirmation: true,
    },

    // Enable password reset
    passwordReset: {
      enabled: true,
    },

    // Configure session fields
    sessionFields: ['userId', 'email', 'name'],

    // Extend User list with custom fields
    extendUserList: {
      fields: {
        // Add a posts relationship
        posts: relationship({
          ref: 'Post.author',
          many: true,
        }),
      },
    },
  }),
)
